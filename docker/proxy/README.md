# Service
- [NGINX Proxy Manager](https://nginxproxymanager.com/)

*NGINX Proxy Manager (NPM) is a cool reverse proxy with a nice GUI to manage your reverse proxies. You can also generate SSL certificates with Let's Encrypt and it will automatically renew them for you.*

# Table of contents

- [Service](#service)
- [Table of contents](#table-of-contents)
- [Compose file](#compose-file)
- [Explanation of the compose file:](#explanation-of-the-compose-file)
  - [General information about the container](#general-information-about-the-container)
  - [Volumes](#volumes)
  - [Specific options](#specific-options)
  - [Network](#network)
- [Run the container](#run-the-container)
- [Service Configuration](#service-configuration)

# Compose file

<details>
<summary>Click to expand</summary>

![compose.yml](./compose.yml)
</details><br>

In this infrasctrucutre, we will use [NGINX Proxy Manager](https://nginxproxymanager.com/) as a Reverse Proxy. <br>
It's an easy-to-use application with a smooth GUI to manage your reverse proxies. You can also generate SSL certificates with Let's Encrypt and it will automatically renew them for you.<br>
> üí° *You will need to get a domain name to fully use the service. Otherwise you'll not be able to generate certificates nor acces your server from the WAN*<br>

> üí° *You can get a free domain name with [DuckDNS](https://www.duckdns.org/), or buy them to a registrar like [Cloudflare](https://cloudflare.com)*


# Explanation of the compose file:

## General information about the container
<details>
<summary>Click to expand</summary>

```yml
---
services:
  proxy:
    image: jc21/nginx-proxy-manager:latest
    restart: always
    container_name: proxy
[...]
```
</details><br>

The first `proxy` defines the name of the service. This is the equivalent as the hostname of the container inside the docker network.<br>
We are using the official image `jc21/nginx-proxy-manager:latest` from Docker Hub. With no tags, the service will always use the latest version of the image.<br>
We define a `container_name` so it's easier to manage containers on our host.<br>
Finally, we define the `restart` policy to `always` so the container will always restart if it stops or if the host reboots.<br>

## Volumes
<details>
<summary>Click to expand</summary>

```yml
[...]
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - /etc/localtime:/etc/timezone:ro
      - /path/to/your/config:/config
      - /path/to/your/certs:/etc/letsencrypt
[...]
```
</details><br>

The two first volumes are used to synchronize the time of the container with the host. This is useful for logs and other time-related operations.<br>
Then, we define where we want to store the configuration files of the service. This folder will contain the proxy configuration and the SSL certificates.<br>
Finally, we define where we want to store the SSL certificates. This folder will be used to store the certificates generated by the service.<br>


## Specific options
> üî¥ *There is no specific option for this service*

## Network
<details>
<summary>Click to expand</summary>

```yml
[...]
    networks:                #1
      - docker_net
    ports:
      - 80:80
      - 81:81
      - 443:443
networks:                   #2
  docker_net:
    external:
      name: jellyfin_docker_net
```
</details>

Then, we ask the container to use the network `docker_net` with `networks: #1` and we expose the port `80 ; 81 ; 443` of the container to the host.

- 80:80   is the default port for HTTP
- 81:81   is the default port for the WebGUI
- 443:443 is the default port for HTTPS

> ‚ö†Ô∏è *At the end of the configuration, you will have to comment or remove the `- 81:81` section as we don't want to expose the WebGUI ports of the host.*

The part `networks: #2` is different from the [`Jellyfin` service](../jellyfin/compose.yml). We are using an external network called `jellyfin_docker_net`. This network is created in the `compose.yml` file of the `Jellyfin` service. This way, the `Jellyfin` service and the `Proxy` service will be able to communicate with each other and also with all the other services in the same network.

# Run the container
To run the container, you can use the following command:
```bash
docker-compose up -d
```
Alternatively, you can specify the path to the compose file:
```bash
docker-compose -f /path/to/your/compose.yml up -d
```
You'll be able to access the web interface of NPM by going to `http://your-server-ip:81` or `http://your-domain-name:81`.

# Service Configuration

Coming soon!